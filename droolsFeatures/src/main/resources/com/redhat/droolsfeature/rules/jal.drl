package com.redhat.jal

import java.util.List;

declare  BzrMarketDeclare
    region : String
    airport : String
    state : String
    world : String
    city : String
    country : String
    matchMap : java.util.HashMap
end

declare Carrier
   carrierCode : String
   opCarrier1 : String  
   opCarrier2 : String
   id : int
end

declare Segment
   origin : BzrMarketDeclare
   destination : BzrMarketDeclare
   carrier : Carrier
   layoverTime : int
   id : int
end

declare Ts
  valid : boolean
  award : boolean
  segments : java.util.List
  calculated : boolean
end

function boolean isBetween(int sid, int sid1, int sid2){
	return (  (sid < sid1 && sid > sid2 ) ||  (sid < sid2 && sid > sid1 ));
}

function int diff(int val, int val2){
	return val2 - val - 1;
}

rule "init"
dialect "mvel" 
no-loop
salience 100000
when
 Ts($segments : segments!=null)
 count : Number(this < $segments.size)
      from accumulate( i : Segment(), count( i ) )
 $segment : Segment(this!=null) from $segments
then
		insert($segment);
end
	

rule "cuba"
 dialect "mvel" 
 when
 	ts : Ts(valid)
 	exists Segment((origin!.country == "CUBA") || (destination!.country == "CUBA"))
 then
   modify(ts){
 	 setValid(false),
   }
 end
 
 
 rule "ISRAEL or ARAB segment"
 dialect "mvel" 
 when
 	ts : Ts(valid)
 	exists Segment((origin!.country in ("ARAB")) || (destination!.country in ("ARAB"))) 
 	exists Segment((origin!.country == "ISRAEL") || (destination!.country == "ISRAEL")) 
  then
   modify(ts){
 	 setValid(false),
   }
 end
/* When we find a point in France Metropolitan AND a point in French Polynesia (there could be several of them in the same ticket),
  then 
  for each of these pairs:
	 Identify the segment(s) which IDs are between the two points: 
	  If every segment has as CarrierCode OR OpCarrier1 OR OpCarrier2 a Japanese airline (based on a list of Japanese Carriers that we have) à IsValid set to no */
	
  
 rule "French Metropolian and French Polynesia V3"	
 dialect "mvel" 
 when
 	 ts : Ts(valid)
 	 sFr : Segment((origin!.country == "FR") || (destination!.country == "FR"))
 	 sPoly : Segment(this != sFr, (origin!.country == "POLY") || (destination!.country == "POLY"), id > sFr!.id)
 	 // on récupère la liste des segments entre un segment France et un autre polynesie 
 	 list : List(size == (sPoly.id-sFr.id-1)) from collect( Segment(id > sFr!.id, id < sPoly!.id, origin!.country not in  ("FR","POLY"), destination!.country not in ("FR","POLY")) )
 	 // on verifie que tous les segments sont opéré par une compagnie japonaise
 	 forall( Segment((carrier!.carrierCode.equals("JAP")) ||  (carrier!.opCarrier1.equals("JAP")) || (carrier!.opCarrier1.equals("JAP"))) from list)	 
 then
  for(Segment seg : list){
  	System.out.println(seg.toString());
  	}
   modify(ts){
 	 setValid(false),
   }
  end
  
  /* rule "Canada - US"	
 dialect "mvel" 
 when
 	 ts : Ts(valid)
 	 sOrigCa : Segment(origin!.country == "CA")
 	 sDestCa : Segment(this != sFr, id > sOrigCa!.id, destination!.country == "CA", destination.city != sOrigCa.origin.city)
 	 // on récupère la liste des segments entre un segment 
 	 list : List(size == (sDestCa.id-sOrigCa.id-1)) from collect( Segment(id > sOrigCa!.id, id < sDestCa!.id, origin!.country in  ("US") || destination!.country in ("FR","POLY")) )
 	 // on verifie que tous les segments sont opéré par une compagnie japonaise
 	 forall( Segment((carrier!.carrierCode.equals("JAP")) ||  (carrier!.opCarrier1.equals("JAP")) || (carrier!.opCarrier1.equals("JAP"))) from list)	 
 then
  for(Segment seg : list){
  	System.out.println(seg.toString());
  	}
   modify(ts){
 	 setValid(false),
   }
  end*/
 
 
 
 
 
 
 
 
 
 
 
 
 